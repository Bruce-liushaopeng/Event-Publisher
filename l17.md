# Lecture 17: Creational Design Patterns

# Recommended Reading: Design Patterns: Elements of Reusable Object-Oriented Software (Chapter 3)

there's 3 mostly, creational, structural, behavioural

# creational patterns

## definition

deal with object creation mechanisms

basic object creation could add complexity

want flexibility, maintainability

control object creation process

# singleton pattern

## intent

ensure a class only has one instance, and global access point to class

## benefits

reduced namespace

better than global variables, have a global class instance that stores global variables

more flexible than static class operators, and global variables

## liabilities

can mask bad design

can be an anti pattern

expose the internal of the singleton to the client in some cases

other components of the program can know too much about each other, can increase coupling

# builder pattern

## intent

separate the construction of a complex object from its representation

## applicability

# if the construction part is too tied to the object itself, it is not applicable

## structure

builder is an interface

concrete builder 1 and 2, for different types of houses

director can change types of which gets built specifically

director tells how to build a suv or a sportscar

## benefits

vary a product's internal representation

single responsibility principle

to isolate code for construction and representation

finer grain control over the construction process

## liabilities

overall complexity increase since pattern requires multiple new classes

# factory method pattern

## intent

interface for creating an object

subclass decide instantiation

## structure

common way of doing something

specific instances, creators, override the common way, like changing the mold to do something specific, or make something specific

## example

if we don't have factory method

render() and onClick() would be coupled between windows button and HTML button

## benefits

avoid tight coupling

single responsibility principle, move product creation into one place in the program

open closed, we don't modify existing stuff

## liabilities

client might have to subclass the creator class just to create a particular ConcreteProduct object

doing something simple might be a pain to do in the program itself

# abstract factory pattern

## intent

provide interface for creating objects without specifying their concrete classes

## structure

the abstract factory is like a registry, it is getting the request for building the product, it refers to the concrete factory, knows the concrete factory classes that can make your request

## example

we don't create a mac button or a windows button, we just create a button, and the abstract factory template itself choose the mac button or the windows button for us

## benefits

avoid tight coupling

single responsibility principle, can extract the product creation code into one place, the abstract factory class

open/closed principle, can introduce new variants of products without breaking existing client code

## liabilities

supporting new kinds of products is difficult

# comparing creational design patterns

subclassing -> factory method

object composition -> abstract factory and builder

design often start out as factory method, and become other creational patterns as more flexibility is needed